# Correspondence Between Paper and Library

This document describes the correspondence between the Agda library called BiSikkel and the POPL25 paper [BiSikkel: A Multimode Logical Framework in Agda](https://doi.org/10.1145/3704844).

## List of claims (high-level)

In this section, we justify the claims made in the *Contributions* section of the introduction (Section 1) of the paper. The correspondence between the rest of the paper and the Agda code will be discussed in the next section.

| Claim                                                                                                                 | Artifact                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| --------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| BiSikkel: an implemenation of MSTT and ¬µLF as an Agda library                                                         | The implementation of MSTT can be found in `BiSikkel/MSTT/`, for ¬µLF the implementation is located in `BiSikkel/LogicalFramework`.                                                                                                                                                                                                                                                                                                                                         |
| BiSikkel is parametrized by a mode theory.                                                                            | The BiSikkel definition of a mode theory is located in `BiSikkel/MSTT/Parameter/ModeTheory.agda`.                                                                                                                                                                                                                                                                                                                                                                          |
| We make Sikkel intrinsically typed and extend it with an equational theory.                                           | The intrinsically typed encoding of MSTT terms is defined as a data type `Tm`¬†from line 92 to 132 in `BiSikkel/MSTT/Syntax/Terms.agda`. The equational theory is implemented in terms of fueled normalization (`BiSikkel/MSTT/Normalization.agda`).                                                                                                                                                                                                                        |
| We give the first implementation of Ceulemans et al.'s modal substitution algorithm and prove its substitution lemma. | The substitution algorithm is implemented in `BiSikkel/MSTT/Syntax/Substitution.agda`. One of the main results in that file is the function `_[_]tm ≥À¢`, which is a general function for applying a renaming/substitution to an MSTT term. The proof of the substitution lemma can be found in `BiSikkel/MSTT/Soundness/Substitution.agda`.                                                                                                                                 |
| We implement a fueled normalization algorithm.                                                                        | The sound normalization algorithm can be found in `BiSikkel/MSTT/Normalization.agda`¬†as the function `normalize`.                                                                                                                                                                                                                                                                                                                                                          |
| We prove BiSikkel sound by modeling ¬µLF in a presheaf model of MTT.                                                   | The entire formalization of the presheaf model can be found in `BiSikkel/Model/`. The proof checker is implemented in `BiSikkel/LogicalFramework/Proof/Checker.agda`¬†as the function `check-proof`¬†and soundness proofs for all inference rules are located in `BiSikkel/LogicalFramework/Proof/Checker/Soundness.agda`.                                                                                                                                                   |
| We implement a proof extraction mechanism. In order to do so, we extend Sikkel's program extraction mechanism.        | Extraction for MSTT is reimplemented and extended (with respect to Sikkel) in `BiSikkel/MSTT/Extraction.agda`. We build further upon this in `BiSikkel/LogicalFramework/bProp/Extraction.agda`¬†to extract propositions and in `BiSikkel/LogicalFramework/Proof/Extraction.agda`¬†to extract proofs.                                                                                                                                                                         |
| We demonstrate the use of BiSikkel by proving properties of functions manipulating guarded streams.                   | The example proofs can be found in `Applications/GuardedRecursion/Examples/Proofs.agda`. The results discussed further on in the paper are `g-map-iterate`¬†and `g-iterate-iterate'`. Apart from these examples, we also have a non-modal example (proving commutativity of natural number addition) in `Applications/NonModal/Examples.agda`¬†and a form of representation independence using unary parametricity in `Applications/UnaryParametricity/BooleanExample.agda`. |

## Paper-to-library correspondence (detailed)

In this section we discuss all definitions, results and code fragments that are included in the paper and we indicate where they can be found in the code base. Any differences between the paper and the library code will also be discussed.

### Section 2: A Brief Overview of Sikkel

#### Section 2.1: Syntactic Layer: Multimode Simple Type Theory (MSTT)

**Mode theory**: The mode theory as described on page 4 is implemented in `BiSikkel/MSTT/Parameter/ModeTheory.agda`. Note that a mode theory is a record of type `ModeTheory`, itself consisting of different other records. As already mentioned in footnote 6, the implementation of a mode theory is more complicated than described in the paper: when constructing a mode theory, one should only describe the non-trivial modes and modalities. The trivial mode `‚òÖ` and the unit modality `ùüô` are automatically added. This has the advantage that some category laws hold strictly (i.e. up to Agda definitional equality). Furthermore, a mode theory in BiSikkel should also specify how modes, modalities, etc. are interpreted in the semantic layer as base categories, DRAs, etc. Finally, some soundness proofs of this interpretation should also be provided (e.g. the interpretation of a composite modality should be equivalent to the DRA composition of the modalities' interpretations).

**Types**: The definition of the data type `Ty` (Figure 2) can be found in `BiSikkel/MSTT/Syntax/Types.agda`. There we also see that there is a constructor `Ext` that allows a user to include new types in a BiSikkel instance (e.g. the type of guarded streams for the guarded recursion instance). This mechanism is further discussed at the end of the readme file of the BiSikkel library.

**Contexts**: The definition of the data type `Ctx` (Figure 2) is located in `BiSikkel/MSTT/Syntax/Contexts.agda`.

**Terms (intrinsically typed)**: The data type `Tm` is defined in `BiSikkel/MSTT/Syntax/Terms.agda`. One can verify that the constructors corresponding to the typing rules in Figure 3 do have a type signature that indeed encodes these inference rules (types and contexts of the conclusion and premises in the figure match those of the result and arguments of the constructor). Note that the modal elimination principle is called `mod-elim`, the let-syntax is only introduced on line 150. Note furthermore that the representation of variables is more complicated than in the paper (constructor `var'`): the De Bruijn index is represented as a value of type `Var x T Œì ‚óá`. The constructors of this `Var` data type allow us to traverse `Œì` from the back to the point where we reach the required variable, and then the appropriate two-cell must be provided. The function `svar` is implemented on line 247. The operation `locks` from Figure 3 is implemented for lock telescopes rather than for contexts (and its definition can be found in `BiSikkel/MSTT/Syntax/Contexts.agda`).

#### Section 2.2: Semantic Layer: Presheaf Models

The formalization of presheaf models is located in `BiSikkel/Model/`. Note that this is a quite extensive development, and it is not really necessary to inspect it in order to use the library to write modal programs/proofs. Of course, one should understand more details when implementing a new instance of BiSikkel.

The interpretation of modes as base categories (see `BiSikkel/Model/BaseCategory.agda`), modalities as dependent adjunctions (DRAs, see `BiSikkel/Model/DRA/Basics.agda`) and two-cells as natural transformations (also called `TwoCell` in the formalization, see `BiSikkel/Model/DRA/TwoCell.agda`) should be specified in a mode theory (`BiSikkel/MSTT/Parameter/ModeTheory.agda`).

The interpretation functions for types and contexts can be found in `BiSikkel/MSTT/Interpretation/TypeContext.agda` as `‚ü¶_‚üßty` and `‚ü¶_‚üßctx` respectively. Note that types are interpreted as a semantic `ClosedTy`, which is the way to specify in our dependently typed formalization of presheaf models (see footnote 9) that a semantic type is actually not dependent (since MSTT is *simply* typed).

The interpretation function for terms is `‚ü¶_‚üßtm` in `BiSikkel/MSTT/Interpretation.agda`.

#### Section 2.3: Extraction to the Meta-level

The original extraction mechanism from Sikkel is not included in BiSikkel because we completely reimplemented it. For MSTT, the mechanism can be found in `BiSikkel/MSTT/Extraction.agda`.

### Section 3: Why a Dedicated Logical Framework?

**Guarded recursion mode theory (Figure 4a)**: The mode theory for guarded recursive type theory is implemented in `Applications/GuardedRecursion/BiSikkel/ModeTheory.agda`. Compared to Figure 4a, the implementation does not only contain the 3 modalities in the figure but also all of their compositions (taking the equalities in the figure into account). Similarly the data type of two-cells (`TwoCell`) also contains the horizontal and vertical compositions arising from the trivial cell and the cells shown in the figure. The semantics of the modalities for guarded recursion are located in `Applications/GuardedRecursion/Model/Modalities/`.

**Guarded streams primitives (Figure 4b)**: The inclusion of the type constructor `GStream` in the syntax layer of the BiSikkel instance is done in `Applications/GuardedRecursion/BiSikkel/TypeExtension.agda`. Similarly, the new term constructors for guarded recursion are specified in `Applications/GuardedRecursion/BiSikkel/TermExtension.agda`. The function `tm-code-ty` specifies the result type for every new term constructor, and the function `tm-code-arginfos` specifies the type and context modifications for all arguments to the term constructors. The semantics of guarded streams can be found in `Applications/GuardedRecursion/Model/Streams/Guarded.agda`.

**Implementation of guarded stream functions (Figure 5)**: The functions from Figure 5 are implemented in `Applications/GuardedRecursion/Examples/Streams.agda`. The rest of that file contains some more examples of guarded streams, and also of standard streams and extraction as described in the last paragraph of Section 3.1 of the paper.

### Section 4: ¬µLF, a Proof System for MSTT

#### Section 4.1: Propositions & Proof Contexts

**Propositions**: The data type `bProp` from Figure 6a is defined in `BiSikkel/LogicalFramework/bProp/Syntax.agda`. It does include an extra constructor `ext` that can be used to extend BiSikkel with custom proposition connectives for specific applications. The definition of "non-modal" implication `‚äÉ` can be found on line 148. It uses a key renaming to introduce the (trivial) lock required in the domain proposition for the constructor `‚ü®_‚à£_‚ü©‚äÉ_`.

**Proof contexts**: The data type `ProofCtx` and function `to-ctx` from Figure 6c are defined in `BiSikkel/LogicalFramework/Proof/Context.agda`. The `locks` operation is actually not defined for proof contexts, but rather for lock telescopes (defined in `BiSikkel/MSTT/Syntax/Contexts.agda`).

#### Section 4.2: Axioms & Inference Rules

**Substitution**: As in the paper, we defer details about substitution to Section 5.4. The definition of the type `Sub` together with the functions `_[_]tm` and `_[_]bprop` can be found in `BiSikkel/MSTT/Syntax/Substitution.agda`. Also the definitions of `_/_` and `_//_` are located on lines 445 and 448 respectively in that file.

**Œ≤-equivalence for terms**: As discussed in the paper, this is implemented via a fueled normalization function in BiSikkel. There is no mechanized treatment of the axiomatic system. However, one can see the rule TmEq-Fun implemented on lines 83-85 in `BiSikkel/MSTT/Normalization.agda` where the term *s* from the inference rule has been replaced by `b` and *t* by `nt`. Similarly, the rule TmEq-Mod is implemented on lines 51-52 of the same file. The function `fuselocks-tm` is used to make the term we are substituting type-check in the right context, as discussed in the paper.

**The proof system**: The inference rules of ¬µLF are not explicitly encoded in BiSikkel. Instead, one can take a look at the definition of the data type `Proof` in `BiSikkel/LogicalFramework/Proof/Definition.agda` (the premises and conclusion for every constructor are also given there as comments) and the proof checking function `check-proof` in `BiSikkel/LogicalFramework/Proof/Checker.agda`. As an example, let us look at the case for `sym` in `check-proof` (lines 65-68): first we make sure that the proposition `œÜ` we want to assign to the proof `sym p` is an equality and bind the two sides to `t1` and `t2`. Then we check that `p` is a valid proof of the proposition `t2 ‚â°·µá t1` in the same context (we do not worry about goals or evidence `‚ü¶p‚üß` at this moment). If this succeeds, we return successfully, and again we do not worry about goals or evidence yet. As we can see, this is indeed a way to check the rule Prf-‚â°·µá-Sym in the paper. In this way, every rule from Figure 8 has a corresponding constructor in the `Proof` data type and a case in the proof checker. We will now discuss the exceptions:

- As already mentioned in the paper, the rule Prf-Beta is not explicitly supported in BiSikkel for performance reasons. Instead, there is a proof construct `with-normalization p` which allows to prove an equality of terms, if `p` proves the equality of their normalizations. Taking `p` to be `refl`, one can immediately show equality of any two Œ≤-equivalent terms. Combining this with the proof constructor `subst`, we can transform a proof of a proposition œÜ to a proof of a proposition œà which only differs from œÜ in that some terms may have been replaced by Œ≤-equivalent ones. In this way the we obtain the same expressivity as the rule Prf-Beta in BiSikkel. Furthermore, if really needed, it would not be too hard to extend normalization to propositions and actually implement Prf-Beta.

- There is a proof constructor `by-unfold-global-def`, which is not covered in Figure 8. This has to do with a term constructor `global-def` that is used for extraction (it allows a term defined in the empty context to be used in any context). From a theoretical point of view, `global-def` just applies a terminal substitution (with the empty context as codomain) to a term and is otherwise completely transparent, which is what the proof constructor above proves.

- The rule Prf-Mod-Elim is slightly more complicated. The version of this rule from Figure 8 would not type-check because œÜ would need to live in both `to-ctx Œû ,lock‚ü® œÅ ‚ü© ,lock‚ü® Œº ‚ü©` (for the 3rd premise) and `to-ctx Œû ,lock‚ü® œÅ ‚ìú Œº ‚ü©` (for the 4th premis), which are not exactly the same contexts. This difference can however be bridged using a renaming, which is what `fuse-locks-bprop` does in the BiSikkel version of Prf-Mod-Elim (proof constructor `mod-elim`).

- There are proof constructors `cong` and `fun-cong` which express congruence of the application term constructor `‚àô` in its second and its first argument respectively (with respect to bProp equality). These constructors do not explicitly correspond to a proof rule in Figure 8, but they are admissible via the rule Prf-‚â°·µá-Subst.

- There are proof constructors `hole` for inserting a hole in a proof and `ext` for extending the BiSikkel proof system with new inference rules. These do not correspond to a rule in Figure 8.

#### Section 4.3: Continuing the g-iterate Example

**New Œ≤-equivalence and proof rules for guarded recursion (Figure 9)**: The implementation of rule TmEq-GStream-Head in the normalizer can be found on line 52 of `Applications/GuardedRecursion/BiSikkel/Normalization.agda`. Similarly TmEq-GStream-Tail is located on line 62 of that file. The proof checker implementations for the rules Prf-TmL√∂b-Beta and Prf-L√∂b are realized via the function `pf-code-check` in `Applications/GuardedRecursion/BiSikkel/ProofExtension.agda`.

**Lemma about g-map and g-iterate**: The proposition we want to prove is called `g-map-iterate` and can be found on line 122-127 of `Applications/GuardedRecursion/Examples/Proofs.agda`. The actual proof is immediately below the proposition and is called `g-map-iterate-proof`. Note that, just like in the paper (equation (6)), the proof starts with two invocations of the introduction rule for ‚àÄ, and then the L√∂b induction rule for proofs, after which an equality chain follows. The equality chain is similar to steps (7-11) in the paper; in the Agda code the proofs for the different steps are included between the angular brackets immediately following the `‚â°·µá` symbols. As mentioned in the paper, step (7) is not included. Step (8) indeed makes use of Prf-TmL√∂b-Beta, encoded in the BiSikkel instance as `tml√∂b-Œ≤` (the use of `with-normalization` has to do with the fact that terms need to be normalized, e.g. to have step (7) be automatically verified). The proof of the lemma mentioned in step (9) is called `g-map-cons-proof` and we apply the elimination principle for ‚àÄ three times to this result. The admissible rule Gcons-Cong used in step (10) is proved in the same file under the name `g-cons-cong`. Note that in step (10) we also use the induction hypothesis named `"ih"` on line 156. Finally, step (11) uses again Œ≤-equivalence and `tml√∂b-Œ≤` as mentioned in the paper (line 159). Note that the syntax `‚â°·µá‚ü® with-normalization tml√∂b-Œ≤ ‚ü®` with the inverted angular bracket in the end, automatically applies `sym` (so it actually provides a proof of the reversed equality). Finally, the function `IsOk` is defined in `BiSikkel/LogicalFramework/Proof/CheckingMonad.agda` and is defined as Agda's unit type `‚ä§` upon success and the empty type `‚ä•` upon failure of a computation in the proof checking monad. As a result, the fact that we can provide a value of `IsOk (check-proof ‚óá (g-map-iterate-proof Nat') (g-map-iterate Nat'))` on line 162-163 of `Applications/GuardedRecursion/Examples/Proofs.agda` means that the proof checker accepts our proof of `g-map-iterate`.

**Final result about g-iterate and g-iterate'**: The proposition is called `g-iterate-iterate'` and is defined on line 169-174 of `Applications/GuardedRecursion/Examples/Proofs.agda`. It is immediately followed by its proof `g-iterate-iterate'-proof` on line 176. As described in the paper, we subsequently use `‚àÄ-intro`, `pfl√∂b` and again `‚àÄ-intro`, after which the equality chain (steps (12-15)) follows. The equality chain is similar to the lemma. One can indeed verify that the steps in the paper are included in the BiSikkel proof. For the last step, we use a lemma `g-iterate'-cons`, whereas the paper claims to use only unfolding of definitions, Œ≤-reduction and the use of Prf-TmL√∂b-Beta. The lemma indeed only makes use of these principles, but we need an intermediate step since Prf-TmL√∂b-Beta cannot immediately be applied to the normalized versions of both sides of the equation.

**Relaing iterate and iterate'**: As stated in the last paragraph of Section 4.3 of the paper, we can prove a similar result relating `iterate` and `iterate'` for standard streams in BiSikkel. This is proven in `iterate-iterate'-proof` in `Applications/GuardedRecursion/Examples/Proofs.agda`. As mentioned in the paper, extraction does work but some performance issues occur. More specifically, it takes too much time to compare the inferred type of the extracted result to the expected Agda type (see also the explanation in the code).

#### Section 4.4: Another Example: Unary Parametricity

The definition of the mode theory is located in `Applications/UnaryParametricity/BiSikkel/ModeTheory.agda`, the extension with `EncBool`in `Applications/UnaryParametricity/BiSikkel/TypeExtension.agda`. The semantics behind the modalities and type/term formers (including the predicate of Booleanness on natural numbers) can be found in `Applications/UnaryParametricity/Model.agda`. The extension of BiSikkel with a new bProp constructor is located in `Applications/UnaryParametricity/BiSikkel/bPropExtension.agda` and the new proof rules in `Applications/UnaryParametricity/BiSikkel/ProofExtension.agda`. The rule Prf-Parametricity corresponds to the `param-code` and Prf-Extent-From corresponds to `extent-from-code`.

We can then construct the proof claimed in the paper in the file `Applications/UnaryParametricity/BooleanExample.agda` and we refer to the comments in the Agda code there. Note that similar to guarded recursion, proof extraction works but comparing the resulting type to the expected Agda type is very slow.

### Section 5: Implementation of ¬µLF in Agda

#### Section 5.1: Agda Representation of Proofs

The definition of the data type `Proof` (i.e. the extrinsically typed representation) can be found in `BiSikkel/LogicalFramework/Proof/Definition.agda`.

#### Section 5.2: The Proof Checker

**Interpretation of propositions and proof contexts**: The function `‚ü¶_‚üßbprop` interpreting propositions in the presheaf model, is located in `BiSikkel/LogicalFramework/bProp/Interpretation.agda`. For the definitions of `‚ü¶_‚üßpctx` interpreting proof contexts and `to-ctx-subst` providing a semantic substitution, we refer to lines 135-146 of `BiSikkel/LogicalFramework/Proof/Context.agda`.

**Proof checking monad**: The proof checking monad and associated operations are defined in `BiSikkel/LogicalFramework/Proof/CheckingMonad.agda`.

**Goals (Figure 11)**: Goals and the result type of the proof checker are defined in `BiSikkel/LogicalFramework/Proof/Checker/ResultType.agda`.

**The proof checker**: The actual implementation of the proof checker can be found in `BiSikkel/LogicalFramework/Proof/Checker.agda`. Soundness of all the cases for the proof checker is proved in `BiSikkel/LogicalFramework/Proof/Checker/Soundness.agda`.

#### Section 5.3: Proof Extraction

Extraction of MSTT contexts, types and terms is defined in `BiSikkel/MSTT/Extraction.agda`. Instances of extractability for many of the MSTT standard type and term constructors can also be found there. Extraction of propositions (as well as many instances) is defined in `BiSikkel/LogicalFramework/bProp/Extraction.agda`. Finally, proof extraction is implemented in `BiSikkel/LogicalFramework/Proof/Extraction.agda`.

The proof of commutativity of natural number addition is located in `Applications/NonModal/Examples.agda`. The illustration of the extraction mechanism for this example can be found on line 166 of that file.

#### Section 5.4: Substitution and (Fueled) Normalization for MSTT

**Substitution**: The substitution algorithm is implemented in `BiSikkel/MSTT/Syntax/Substitution.agda`. In order to capture the behavior of pushing a substitution/renaming through term constructors until a variable is reached, we also introduce the concept of term traversals there. The soundness of the substitution algorithm with respect to the presheaf model of MSTT is proven in `BiSikkel/MSTT/Soundness/Substitution.agda`. This proof largely follows the structure of the implementation of the substitution algorithm (traversals, atomic and regular rensubs, etc.)

**Fueled Normalization**: The result type of normalization as shown on page 25 is defined in `BiSikkel/MSTT/Normalization/ResultType.agda`. The actual normalization function is then implemented in `BiSikkel/MSTT/Normalization.agda`.
